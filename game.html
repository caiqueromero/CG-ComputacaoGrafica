<!DOCTYPE html>
<html lang="en">
<head>
<title>Game</title>
<meta charset="utf-8">
<meta name="viewport"
	content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
	color: #888888;
	font-family: Monospace;
	font-size: 13px;
	background-color: #000;
	margin: 0px;
	overflow: hidden;
}

#info {
	position: absolute;
	top: 0px;
	width: 200px;
	left: calc(50% - 100px);
	text-align: center;
}

a {
	color: #00f;
}
</style>
</head>
<body>

	<div id="container"></div>

	<script src="lib/build/three.min.js"></script>
	<script src="lib/build/controls/orbit_controls.js"></script>
	<script src="lib/build/Mirror.js"></script>
	<script src="lib/build/controls/THREEx.KeyboardState.js"></script>

	<script>
		// scene size
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;

		// camera
		var VIEW_ANGLE = 45;
		var ASPECT = WIDTH / HEIGHT;
		var NEAR = 1;
		var FAR = 500;

		var camera, scene, renderer;

		var cameraControls;

		var sphereGroup, smallSphere;
		var keyboard = new THREEx.KeyboardState();
		var mainLight;

		var fullGround = new Array();

		var audio = document.createElement('audio');
		var source = document.createElement('source');
		source.src = 'songs/game_song.wav';
		audio.appendChild(source);
		audio.loop = true;
		audio.play();

		var FRENTE = 1;
		var DIREITA = 2;
		var ESQUERDA = 3;

		init();
		animate();

		function init() {

			var MAP = [ FRENTE, DIREITA, DIREITA, DIREITA, FRENTE, FRENTE,
					FRENTE, DIREITA, DIREITA, FRENTE, ESQUERDA, ESQUERDA,
					FRENTE, FRENTE ];
			var container = document.getElementById('container');

			// renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(WIDTH, HEIGHT);
			container.appendChild(renderer.domElement);

			// scene
			scene = new THREE.Scene();

			// camera
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			camera.position.set(0, 75, 160);

			cameraControls = new THREE.OrbitControls(camera,
					renderer.domElement);
			//  cameraControls.target.set(0, 40, 0);
			cameraControls.maxDistance = 400;
			cameraControls.minDistance = 10;
			//  cameraControls.update();

			var loader = new THREE.TextureLoader();

			var planeGeo = new THREE.PlaneGeometry(50.1, 150.1);

			var material = new THREE.MeshPhongMaterial();

			material.side = THREE.DoubleSide;

			var ground = new THREE.Mesh(planeGeo, material);

			ground.rotateX(-Math.PI / 2);

			material.map = loader.load("img/textura.jpg", function(texture) {
				planeGeo.map = texture;
			});

			material.bumpMap = loader.load("img/textura_bump.png");
			material.bumpScale = 1;

			scene.add(ground);

			fullGround.push(ground);

			console.info(ground);

			var lastZ = 0.0;
			var lastX = 0.0;

			for (var i = 0; i < MAP.length; i++) {
				var map = ground.clone();
				var index = (i + 1);

				if (MAP[i] == FRENTE) {
					lastZ -= 150;
					if ((i - 1) >= 0 && (MAP[i - 1] == DIREITA)) {
						lastX += 50;
						lastZ += 50;
					} else if ((i - 1) >= 0 && (MAP[i - 1] == ESQUERDA)) {
						lastX -= 50;
						lastZ += 50;
					}
					map.position.z = lastZ;
					map.position.x = lastX;
				} else if (MAP[i] == DIREITA) {
					map.rotateZ(-Math.PI / 2);
					lastZ -= 50;
					lastX += 100;

					map.position.x = lastX;
					map.position.z = lastZ;

				} else if (MAP[i] == ESQUERDA) {
					map.rotateZ(-Math.PI / 2);

					lastZ -= 50;
					lastX -= 100;

					map.position.x = lastX;
					map.position.z = lastZ;
				}

				lastX = map.position.x;
				lastZ = map.position.z;

				fullGround.push(map);
				scene.add(map);
			}

			var geometry = new THREE.IcosahedronGeometry(12, 2);
			var material = new THREE.MeshPhongMaterial();

			smallSphere = new THREE.Mesh(geometry, material);
			smallSphere.position.y = 24 * Math.sin(Math.PI / 180 * 30); // 12
			// 			smallSphere.position.y = -12;

			material.map = loader.load("img/textura.jpg", function(texture) {
				smallSphere.map = texture;
			});

			scene.add(smallSphere);
			// lights
			mainLight = new THREE.PointLight(0xcccccc, 1.5, 250);
			mainLight.position.y = 60;
			scene.add(mainLight);
		}

		var velocidadeMax = 5;
		var velocidade = 0;
		var rotacaoVelo = 0.2;

		var length = fullGround.length;
		var b = false;

		function move(code) {
			// 			var timer = Date.now() * 0.01;
			var timer = 0.0051;
			if (code == 119) { // sobe
				moveUp(timer);
			} else if (code == 97) { // esquerda
				moveLeft(timer);
			} else if (code == 100) { // direita
				moveRigth(timer);
			} else if (code == 115) { // desce
				moveDown(timer);
			}

			if (velocidade < velocidadeMax) {
				velocidade += 0.4;
			}

			if (!b) {
				smallSphere.position.y = 24 * Math.sin(Math.PI / 180 * 30);
			}
		}

		function moveRigth(timer) {
			smallSphere.rotation.z -= timer * velocidade;
			smallSphere.position.x += 2;
			camera.position.x += 2;
			mainLight.position.x += 2;
		}

		function moveLeft(timer) {
			smallSphere.rotation.z += timer * velocidade;
			smallSphere.position.x -= 2;
			camera.position.x -= 2;
			mainLight.position.x -= 2;
		}

		function moveUp(timer) {
			smallSphere.rotation.x -= timer * velocidade;
			smallSphere.position.z -= 2;
			camera.position.z -= 2;
			mainLight.position.z -= 2;
		}

		function moveDown(timer) {
			smallSphere.rotation.x += timer * velocidade;
			smallSphere.position.z += 2;
			camera.position.z += 2;
			mainLight.position.z += 2;
		}

		var rigth = false, up = false, down = false, left = false;
		var rolling = false;
		function reset() {
			rigth = false;
			up = false;
			left = false;
			down = false;
		}

		function animate() {

			requestAnimationFrame(animate);

			if (keyboard.pressed("p")) {
				rolling = true;
			}

			if (b) {
				smallSphere.position.y -= 1.5;
			}

			if (keyboard.pressed("d")) {
				move(100);
				reset();
				rigth = true;
			} else if (keyboard.pressed("a")) {
				move(97);
				reset();
				left = true;
			} else if (keyboard.pressed("w")) {
				move(119);
				reset();
				up = true;
			} else if (keyboard.pressed("s")) {
				move(115);
				reset();
				down = true;
			}

			if (velocidade > 0) {
				var moviment = 0.3 * velocidade;
				if (rigth) {
					smallSphere.rotation.z -= moviment;
					smallSphere.position.x += moviment;
					camera.position.x += moviment;
					mainLight.position.x += moviment;
				} else if (down) {
					smallSphere.rotation.x += moviment;
					smallSphere.position.z += moviment;
					camera.position.z += moviment;
					mainLight.position.z += moviment;
				} else if (up) {
					smallSphere.rotation.x -= moviment;
					smallSphere.position.z -= moviment;
					camera.position.z -= moviment;
					mainLight.position.z -= moviment;
				} else if (left) {
					smallSphere.rotation.z += moviment;
					smallSphere.position.x -= moviment;
					camera.position.x -= moviment;
					mainLight.position.x -= moviment;
				}
				velocidade -= 0.1;
			} else {
				reset();
			}

			var timer = Date.now() * 0.01;
			camera.lookAt(smallSphere.position);
			// 			sphereGroup.position.x += 0.2;

			// 			smallSphere.position.set(
			// 					Math.cos(timer * 0.1) * 30,
			// 					Math.abs(Math.cos(timer * 0.2)) * 20 + 5,
			// 					Math.sin(timer * 0.1) * 30
			// 					);
			// 			smallSphere.rotation.y = (Math.PI / 2) - timer * 0.1;
			// 			smallSphere.rotation.z = timer * 0.8;

			// 			camera.position.z -= 1;
			// 			camera.position.y += 5;

			// 			mainLight.target = smallSphere;

			// 			cameraControls.update();
			colided();
			renderer.render(scene, camera);
		}

		function colided() {
			var estouDentroDoMapa = true;
				
			var ballX = smallSphere.position.x;
			var ballY = smallSphere.position.z;
			var ballZ = smallSphere.position.z;
			
			for (var i = 0; i < length; i++) {

				var ground = fullGround[i];

				for (var vertexIndex = 0; vertexIndex < ground.geometry.vertices.length; vertexIndex++) {
					var groundX = ground.geometry.vertices[vertexIndex].x;
					var groundY = ground.geometry.vertices[vertexIndex].y;
					
					if (groundX < 0 && ballX < (groundX - ground.position.x)) {
						estouDentroDoMapa = false;
						break;
					}
					
					if (groundX > 0 && ballX > (groundX + ground.position.x)) {
						estouDentroDoMapa = false;
						break;
					}
					
// 					if (groundY < 0 && ballY > (groundY - ground.position.z)) {
// 						estouDentroDoMapa = true;
// 						break;
// 					}
				}
			}

			if (!estouDentroDoMapa) {
				b = true;
			}
		}
	</script>
</body>
</html>
